***(

    This file is part of SMaude, a framework for supporting
    synchronous set rewriting in Maude.

    Copyright (C) 2008-2013 Camilo Rocha, camilo.rocha@gmail.com

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
)

****                                                    Tests for meta-matching
****                                                       Author: Camilo Rocha
****                                        To be used with Maude 2.6 or higher
****                                                 Taken from Full Maude 2.6b

fmod TERM-HANDLING is
  protecting META-TERM .
  protecting META-LEVEL .
  protecting EXT-BOOL . *** For and-then

  var T T' T'' : Term .
  var C C' : Constant .
  var QIL : QidList .
  var N N' : Nat .
  var NL NL' : NatList .
  var Q F F' : Qid .
  var AtS : AttrSet .
  var EqS : EquationSet .
  var Eq : Equation .
  var Cond : Condition .
  var TP : Type .
  var TPL TPL' : TypeList .
  var TL TL' TL'' : TermList .
  var B : Bool .
  var V V' : Variable .
  var Ct : Context .
  var CtL : NeCTermList .
  var NeTL : NeTermList .
  var M : Module .

  *** root  ******************************
  op root : Term -> Qid .
  eq root(V) = V .
  eq root(C) = C .
  eq root(F[TL]) = F .

  *** size  ******************************
  op size : TermList -> Nat .
  eq size(empty) = 0 .
  eq size((T,TL)) = s(size(TL)) .

  *** elem_of_ *****************************************************
  op elem_of_ : Nat TermList ~> Term .
  eq elem 1 of (T,TL) = T .
  eq elem s(s(N)) of (T,TL) = elem s(N) of TL .

  *** subTerm_of_ *****************************************************
  op subTerm_of_ : NatList Term ~> Term .
  eq subTerm NL of T = subTerm* NL of T  .

  op subTerm*_of_ : NatList Term ~> Term .
  eq subTerm* nil of T = T .
  eq subTerm* N NL of (F[TL]) = subTerm* NL of (elem N of TL) .

  *** ToDo: UPGRADE THIS NOTION TO MODULO AC *********************
  *** is_subTermOf_ *****************************************************
  op is_subTermOf_ : Term TermList -> Bool .
  eq is T subTermOf T = true .
  eq is T subTermOf (F[TL]) = is T subTermOf TL .
  eq is T subTermOf (T',NeTL) = is T subTermOf T' 
                                or-else is T subTermOf NeTL .
  eq is T subTermOf T' = false [owise] .

  *** noVarOfSort_In_ *****************************************************
  op noVarOfSort_In_ : Type TermList -> Bool .
  eq noVarOfSort T:Type In V = getType(V) =/= T:Type .
  eq noVarOfSort T:Type In (F[TL]) = noVarOfSort T:Type In TL .
  eq noVarOfSort T:Type In (T',NeTL)
   = noVarOfSort T:Type In T' and noVarOfSort T:Type In NeTL .
  eq noVarOfSort T:Type In X:TermList = true [owise] .

  *** findSubTermOf_In_ ***********************************************
  op findSubTermOf_In_ : NeCTermList TermList ~> Term .
  eq findSubTermOf (TL, [], TL') In (TL, T, TL') = T .
  eq findSubTermOf (TL, F[CtL], TL'') In (TL, F[TL'], TL'')
   = findSubTermOf CtL In TL' .

  *** replaceElem_of_by_ ****************************************************
  op replaceElem_of_by_ : Nat TermList Term ~> TermList .
  eq replaceElem 1 of (T,TL) by T' = (T',TL) .
  eq replaceElem s(s(N)) of (T,TL) by T' = (T,replaceElem s(N) of TL by T') .

  *** replaceSubTerm_of_by_ *************************************************
  op replaceSubTerm_of_by_ : NatList TermList Term ~> TermList .
  eq replaceSubTerm nil of T by T' = T' .
  eq replaceSubTerm N NL of (F[TL]) by T'
   = F[replaceSubTermL N NL of TL by T'] .

  op replaceSubTermL_of_by_ : NatList TermList Term ~> TermList .
  eq replaceSubTermL 1 NL of (T,TL) by T'
   = (replaceSubTerm NL of T by T', TL) .
  eq replaceSubTermL s(s(N)) NL of (T,TL) by T'
   = (T,replaceSubTermL s(N) NL of TL by T') .

  op replaceTerm_by_in_ : Term Term TermList ~> TermList .
  eq replaceTerm T by T' in T = T' .
  eq replaceTerm T by T' in (F[TL]) = F[replaceTerm T by T' in TL] .
  eq replaceTerm T by T' in T'' = T'' [owise] .
  eq replaceTerm T by T' in (T'',NeTL) 
   = (replaceTerm T by T' in T'',replaceTerm T by T' in NeTL) .

  *** context replacement **************************************************

  op _[_] : Context Context -> Context .
  op _[_] : NeCTermList Context -> NeCTermList .
  eq [] [ Ct ] = Ct .
  eq (F[CtL])[ Ct ] = F[ CtL [ Ct ] ] .
  eq (CtL,NeTL) [Ct] = (CtL [Ct] ), NeTL .
  eq (NeTL,CtL) [Ct] = NeTL, (CtL [Ct] ) .

  op _[_] : Context Term -> Term .
  op _[_] : NeCTermList Term -> TermList .
  eq [] [ T ] = T .
  eq (F[CtL])[ T ] = F[ CtL [ T ] ] .
  eq (CtL,NeTL) [T] = (CtL [T] ), NeTL .
  eq (NeTL,CtL) [T] = NeTL, (CtL [T] ) .

  *** is_substring_ *****************************************
  op is_substring_ : Qid Qid -> Bool [memo] .
  eq is F:Qid substring F':Qid
   = rfind(string(F':Qid), string(F:Qid), length(string(F':Qid))) =/= notFound .

  *** addprefix_To_ addsufix_To_ *****************************************
  op addprefix_To_ : Qid Variable -> Variable [memo] .
  eq addprefix Q To V
   = qid(string(Q) + string(getName(V)) + ":" + string(getType(V))) .
   
  op addprefix_To_ : Qid Constant -> Constant [ditto] .
  eq addprefix Q To F
   = if noUnderBar(F) and getName(F) :: Qid then
       if getType(F) :: Type then
         qid(string(Q) + string(getName(F)) + "." + string(getType(F)))
       else
         qid(string(Q) + string(getName(F)))
       fi
     else
       qid(string(Q) + string(F))
     fi .

  op addsufix_To_ : Qid Variable -> Variable [memo] .
  eq addsufix Q To V
   = qid(string(getName(V)) + string(Q) + ":" + string(getType(V))) .
   
  op addsufix_To_ : Qid Constant -> Constant [ditto] .
  eq addsufix Q To F
   = if noUnderBar(F) and getName(F) :: Qid then
       if getType(F) :: Type then
         qid(string(getName(F)) + string(Q) + "." + string(getType(F)))
       else
         qid(string(getName(F)) + string(Q))
       fi
     else
       qid(string(F) + string(Q))
     fi .

  op addType_ToVar_ : Type Qid -> Variable [memo] .
  eq addType TP:Qid ToVar V:Qid
   = qid(string(V:Qid) + ":" + string(TP:Qid)) .

  *** noUnderBar (auxiliary) ****************************
  op noUnderBar : Qid -> Bool .
  eq noUnderBar(F)
   = rfind(string(F), "_", length(string(F))) == notFound .

  *** addType  ******************************
  op addType : Qid Type -> Qid .
  eq addType(F,TP)
   = if noUnderBar(F) and getName(F) :: Qid then
       qid( string(getName(F)) + "." + string(TP) )
     else
       qid( string(F) + "." + string(TP) )
     fi .

  *** addTypeVar  ******************************
  op addTypeVar : Qid Type -> Qid .
  eq addTypeVar(F,TP)
   = qid( string(F) + ":" + string(TP) ) .

  *** createTerm  ******************************
  op createTerm : Qid TypeList -> Term .


endfm

--- Taken from Full Maude 2.6b
fmod SUBSTITUTION-HANDLING is
  protecting META-TERM .
  protecting META-LEVEL .
  protecting TERM-HANDLING .

  var S S' Subst Subst' : Substitution .
  var V V' : Variable .
  var C C' : Constant .
  var Ct : Context .
  var T T' T1 T2 T1' T2' T1'' T2'' : Term .
  var F F' : Qid .
  var TL TL' TL1 TL2 TL1' TL2' : TermList .
  var Att : AttrSet .
  var RLS : RuleSet .
  var Rl : Rule .
  var TP : Type .
  var N : Nat .
  var NeTL : NeTermList .
  var CtL : NeCTermList .

  --- Apply Substitution to Term --------------------------------------------
  op _<<_ : Term Substitution -> Term .
  eq TL << none = TL .
  eq C << Subst = C .
  eq V << ((V <- T) ; Subst) = T .
  eq V << Subst = V [owise] .
  eq F[TL] << Subst = F[TL << Subst] .

  op _<<_ : TermList Substitution -> TermList .
  eq (T, NeTL) << Subst = (T << Subst, NeTL << Subst) .
  eq empty << Subst = empty .

  op _<<_ : Context Substitution -> Context .
  eq Ct << none = Ct .
  eq [] << Subst = [] .
  eq F[CtL,NeTL] << Subst = F[CtL << Subst,NeTL << Subst] .
  eq F[NeTL,CtL] << Subst = F[NeTL << Subst, CtL << Subst] .
  eq F[Ct] << Subst = F[Ct << Subst] .

  op _<<_ : Substitution Substitution -> Substitution .
  eq S << (none).Substitution = S .
  eq (none).Substitution << S = (none).Substitution .
  eq ((V' <- T) ; S') <<  S
   = (V' <- (T << S))
     ;
     (S' << S) .

  --- Combine Substitutions -------------------------------------------------
  op _.._ : Substitution Substitution -> Substitution .
  eq S .. S' = (S << S') ; S' .

  --- Restrict Assignments to Variables in a Term ----------------------
  op _|>_ : Substitution TermList -> Substitution .

  eq Subst |> TL = Subst |>* Vars(TL) .

  op _|>*_ : Substitution TermList -> Substitution .
---   eq noMatch |>* TL = noMatch .
  eq Subst |>* TL = Subst |>** TL [none] .

  op _|>**_[_] : Substitution TermList 
                 Substitution -> Substitution .
  eq none |>** TL [Subst']
   = Subst' .
  eq ((V <- V) ; Subst) |>** TL [Subst']
   = Subst |>** TL [Subst'] .
  eq ((V <- T') ; Subst) |>** TL [Subst']
    = Subst |>** TL
      [Subst' ; if any V in TL then (V <- T') else none fi] . 

  --- Remove Variables from list ----------------------
  op _intersect_ : TermList TermList -> TermList .
  eq (TL1,T,TL2) intersect (TL1',T,TL2') 
   = (T,((TL1,TL2) intersect (TL1',TL2'))) .
  eq TL intersect TL' = empty [owise] .

  op _intersectVar_ : TermList TermList -> TermList .
  eq TL1 intersectVar TL2 
   = TL1 intersectVar* Vars(TL2) . 

  op _intersectVar*_ : TermList TermList -> TermList .
  eq (T,TL1) intersectVar* TL2 
   = (if any Vars(T) in TL2 then T else empty fi,TL1 intersectVar* TL2) .
  eq empty intersectVar* TL2 
   = empty .

  --- Variables ---
  op Vars : GTermList -> TermList .
  eq Vars((T,TL:GTermList)) = VarsTerm(T),Vars(TL:GTermList) .
  eq Vars((Ct,TL:GTermList)) = VarsTerm(Ct),Vars(TL:GTermList) .
  eq Vars(empty) = empty .
  
  op VarsTerm : Term -> TermList . ---warning memo
  eq VarsTerm(V) = V .
  eq VarsTerm(F[TL:TermList]) = Vars(TL:TermList) .
  eq VarsTerm(C) = empty .
  
  op VarsTerm : Context -> TermList . ---warning memo
  eq VarsTerm(F[TL:GTermList]) = Vars(TL:GTermList) .
  
  --- membership ---
  op _in_ : Term TermList -> Bool .
  eq T in (TL,T,TL') = true .
  eq T in TL = false [owise] .
  
  --- membership ---
  op any_in_ : TermList TermList -> Bool . --- [memo] .
  eq any empty in TL = false .
  eq any (TL1,T,TL2) in (TL1',T,TL2') = true .
  eq any TL in TL' = false [owise] .
  
  --- membership ---
  op all_in_ : TermList TermList -> Bool . --- [memo] .
  eq all empty in TL = true .
  eq all (TL1,T,TL2) in (TL1',T,TL2') = all (TL1,TL2) in (TL1',T,TL2') .
  eq all TL in TL' = false [owise] .
  
  --- Occur check ---
  op allVars_inVars_ : GTermList GTermList -> Bool .
  eq allVars TL:GTermList inVars TL':GTermList 
   = all Vars(TL:GTermList) in Vars(TL':GTermList) .

  op anyVars_inVars_ : GTermList GTermList -> Bool .
  eq anyVars TL:GTermList inVars TL':GTermList 
   = any Vars(TL:GTermList) in Vars(TL':GTermList) .

---   op dom : Substitution -> TermList .
---   eq dom(V <- T ; Subst) = (V,dom(Subst)) .
---   eq dom(none) = empty .
  
---   op range : Substitution -> TermList .
---   eq range(V <- T ; Subst) = (T,range(Subst)) .
---   eq range(none) = empty .

  op rangeVars : Substitution -> TermList .
  eq rangeVars(V <- T ; Subst) = (Vars(T),rangeVars(Subst)) .
  eq rangeVars(none) = empty .

  op dom_inVars_ : Substitution TermList -> Bool .
  eq dom Subst inVars TL = dom Subst in Vars(TL) .

  op dom_in_ : Substitution TermList -> Bool .
  eq dom (V <- T ; Subst) in (TL1,V,TL2) = true .
  eq dom Subst in TL = false [owise] .

  op range_inVars_ : Substitution TermList -> Bool .
  eq range Subst inVars TL = range Subst in Vars(TL) .

  op range_in_ : Substitution TermList -> Bool .
  eq range (V <- T ; Subst) in TL
   = any Vars(T) in TL or-else range Subst in TL .
  eq range none in TL
   = false .

  op valid-occur-check? : Substitution -> Bool .
  eq valid-occur-check?(Subst)
   = not (dom Subst inVars (rangeVars(Subst))) .
endfm

fmod BASE is
  sorts Aid Eid Expr Val .
  subsort Val Eid < Expr .
endfm

view Aid from TRIV to BASE is
  sort Elt to Aid .
endv

view Expr from TRIV to BASE is
  sort Elt to Expr .
endv

fmod ELEM is
  pr MAP{Aid,Expr} * (sort Map{Aid,Expr} to Map,
                      sort Entry{Aid,Expr} to Cell,
                      op _|->_ to _:_) .
  sort Elem .
  op <_|_> : Eid Map -> Elem [prec 122] .
endfm 

view Elem from TRIV to ELEM is
  sort Elt to Elem .
endv

fmod CTX is
  pr SET{Elem} * (sort Set{Elem} to Ctx,
                  sort NeSet{Elem} to NeCtx,
                  op _,_ : Set{Elem} Set{Elem} -> Set{Elem} 
                    to (__) [prec 123]) .
endfm

fmod SMAUDE-BASE is
  pr BASE .
  pr CTX .
  op eval : Expr -> Val .
  op eval : Ctx Expr -> Val .
endfm

fmod EXAMPLE-SIG is
  inc SMAUDE-BASE .
  subsort Nat < Expr .
  ops u v w : -> Aid .
  ops a b c : -> Eid .
  eq eval(CX:Ctx,N:Nat) = N:Nat .
endfm

mod EXAMPLE is
  inc EXAMPLE-SIG .
  inc REDEXES .

  vars I J : Eid .
  vars X Y : Nat .

  rl [r-1] : 
     < I | w : X >
  => < I | w : 5 > .

  rl [r-2] : 
     < I | v : X > < J | w : Y >
  => < I | v : eval(X + Y) > .

  op init : -> Ctx .
  eq init = < a | u : 1, v : 2 > < b | u : 1, w : 0 > < c | w : 1 > .
endm

fmod CLOSURE is
  pr META-LEVEL .

  var  AtS       : AttrSet .
  var  C         : Condition .
  var  ES        : EquationSet .
  var  H         : Header .
  var  IL        : ImportList .
  var  MAS       : MembAxSet .
  var  ODS       : OpDeclSet .
  vars RS RS'    : RuleSet .
  var  SS        : SortSet . 
  var  SDS       : SubsortDeclSet .
  var  S         : String .
  vars T T' T''  : Term .
  vars TL TL'    : TermList .

*** Computes the closure of the left-hand side of the rules in
*** in the given module
  op close-lhs : Module -> Module .
  eq close-lhs(mod H is IL sorts SS . SDS ODS MAS ES RS endm)
   = mod H is IL sorts SS . SDS ODS MAS ES close-lhs(RS) endm .

  op close-lhs : RuleSet -> RuleSet .
  eq close-lhs(RS) = close-lhs*(RS,none) .
  op close-lhs* : RuleSet RuleSet -> RuleSet .
  eq close-lhs*(none, RS') = RS' .
  eq close-lhs*((rl T => T' [AtS].) RS, RS')
   = close-lhs*(RS, (rl close(T) => T' [AtS].) RS') .
  eq close-lhs*((crl T => T' if C [AtS].) RS, RS')
   = close-lhs*(RS, (crl close(T) => T' if C [AtS].) RS') .

*** Closure constant name which is used for the name of
*** the closure variable for the left-hand side of the rules
*** and as a prefix for the variable for the closure map of
*** each element
  op CLSRCNST : -> String .
  eq CLSRCNST = "#X#" .

*** Closes the given term that is assummed to be the metarepresentation
*** of a term with sort Ctx. It uses the auxiliary function "close*"
*** to close all maps of elements in the context
  op close  : Term -> Term .
  eq close('<_|_>[TL])
   = '__[qid(CLSRCNST + ":Ctx"),close*('<_|_>[TL],CLSRCNST)] .
  eq close('__[TL:TermList])
   = '__[qid(CLSRCNST + ":Ctx"),close*(TL,CLSRCNST)] .

*** Closes the give term assumin it metarepresents a list of elements
  op close* : TermList String -> TermList .
  eq close*(empty,S) = empty .
  eq close*(('<_|_>[T,'_:_[TL]],TL'),S)
   = ('<_|_>[T,'_`,_['_:_[TL],qid(S + string(getName(T)) + ":Map")]]), close*(TL',S) .
  eq close*(('<_|_>[T,'_`,_[TL]],TL'),S)
   = ('<_|_>[T,'_`,_[TL,qid(S + string(getName(T)) + ":Map")]],TL'), close*(TL',S) .
endfm

fmod BASE-SUBSTITUTION is
  pr META-LEVEL .
  pr SUBSTITUTION-HANDLING .
  pr SMAUDE-BASE .
  pr CLOSURE .

*** Application of substitutions
  op applSubs : Term Substitution? -> Term .
  eq applSubs(T:Term, noMatch)
   = upTerm((empty).Ctx) .
  eq applSubs(T:Term,S:Substitution)
   = T:Term << S:Substitution .

*** Substitutions
  op getSubs : Module Qid Term Nat -> Term .
  eq getSubs(M:Module,Q':Qid,T:Term,N:Nat)
   = getSubs(M:Module,getRule(Q':Qid,getRls(M:Module)),T:Term,N:Nat) .

  op getSubs : Module Rule Term Nat -> Term .
  eq getSubs(M:Module, rl T:Term => T':Term [AtS:AttrSet]., T'':Term, N:Nat)
   = applSubs(T:Term, metaMatch(M:Module, close(T:Term), T'':Term, nil, N:Nat)) .

  op getRule : Qid RuleSet ~> Rule .
  eq getRule(Q:Qid, ((rl T:Term => T':Term [AtS:AttrSet label(Q:Qid)].) RlS:RuleSet))
   = rl T:Term => T':Term [AtS:AttrSet label(Q:Qid)]. .
endfm

fmod REDEXES is
  pr BASE-SUBSTITUTION .

  vars C C' C'' : Ctx .
  var  E        : Eid .
  vars M M'     : Map .
  var  N        : Nat .
  vars Q Q'     : Qid .
  var  T        : Term .

*** Down function for contexts
  op errorCtx : -> [Ctx] .
  op downCtx  : Term -> Ctx .
  eq downCtx(T) = downTerm(T,errorCtx) .

*** Getting the redexes of a term
  op getRedexes : Qid Qid Ctx Nat -> Ctx .
  eq getRedexes(Q,Q',C,N)
   = filterContext(C,downCtx(getSubs(upModule(Q,false),Q',upTerm(C),N))) .

  op filterContext : Ctx Ctx -> Ctx .
  op filterContext* : Ctx Ctx Ctx -> Ctx .
  eq filterContext(C,C') = filterContext*(C,C',(empty).Ctx) .
  eq filterContext*( (< E | M > C), (< E | M' > C'), C'')
   = filterContext*(C, (< E | M' > C'), (< E | M > C'')) .
  eq filterContext*(C,C',C'') = C'' [owise] .
endfm

select EXAMPLE .