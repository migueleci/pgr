***(

    This file is part of SMaude, a framework for supporting
    synchronous set rewriting in Maude.

    Copyright (C) 2008-2013 Camilo Rocha, camilo.rocha@gmail.com

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
)

****                                  Infrastructure for synchronous reductions
****                                                       Author: Camilo Rocha
****                                        To be used with Maude 2.6 or higher

fmod TRANSITION is
  pr 2TUPLE{Ctx,Ctx}
     * (sort Tuple{Ctx,Ctx} to SimpleTransition) .
  pr 4TUPLE{String,Rat,Ctx,Ctx}
     * (sort Tuple{String,Rat,Ctx,Ctx} to Transition) .

  sort SimpleTransitionMagma .
  subsort SimpleTransition < SimpleTransitionMagma .
  op mtstm : -> SimpleTransitionMagma [ctor] .
  op _,_ : SimpleTransitionMagma SimpleTransitionMagma -> SimpleTransitionMagma [assoc comm id: mtstm] .
  eq ST:SimpleTransition , ST:SimpleTransition = ST:SimpleTransition .

  sorts TransitionList TransitionListMagma .
  subsort Transition < TransitionList < TransitionListMagma .
  op niltl : -> TransitionList [ctor] .
  op _;_ : TransitionList TransitionList -> TransitionList [assoc id: niltl] .
  op mttlm : -> TransitionListMagma [ctor] .
  op _,_   : TransitionListMagma TransitionListMagma -> TransitionListMagma [assoc comm id: mttlm] .

  var  C C' C1 C2 : Ctx .
  var  E          : Eid .
  vars M M'       : Map .
  var  N          : Nat .
  vars R R'       : Rat .
  var  ST         : SimpleTransition .
  var  STM        : SimpleTransitionMagma .
  vars S S'       : String .
  var  T          : Transition .
  var  TL TL' TL1 : TransitionList .
  var  TLM        : TransitionListMagma .

  --- computes the lenght of a list of transitions
  op length : TransitionList -> Nat [memo] .
  eq length(niltl) = 0 .
  eq length(T ; TL) = s(length(TL)) .

  --- two transitions are disjoint iff their two third
  --- components are disjoint
  op disjoint? : TransitionList -> Bool .
  eq disjoint?(TL ; (S,R,C < E | M >, C') ; TL' ; (S',R',C1 < E | M' > ,C2) ; TL1)
   = false .
  eq disjoint?(TL) = true [owise] .

  --- computes the union of the transitions in a list of transitions
  --- into a simple transition
  op to-simple-trans : TransitionList -> SimpleTransition .
  op $to-simple-trans : TransitionList SimpleTransition -> SimpleTransition .
  eq to-simple-trans(TL) = $to-simple-trans(TL,((empty),(empty))) .
  eq $to-simple-trans(niltl, ST) = ST .
  eq $to-simple-trans( (S,N,C1,C2) ; TL , (C,C'))
   = $to-simple-trans(TL ,(C C1,C' C2)) .

  --- Clears a set of simple transitions of subsumptions.
  --- A simple transition ST is subsumed by a simple transition ST'
  --- when the first component of ST is subset of the first
  --- component of ST'
  op subsume : SimpleTransitionMagma -> SimpleTransitionMagma .
  eq subsume(((C,C'),(C C1,C' C2),STM))
   = subsume(((C C1,C' C2),STM)) .
  eq subsume(STM) = STM [owise] .

  --- given a list of transitions of size n>0, this function
  --- computes all n sublists of size n-1 (where the sublists
  --- need not respect the order of the input list).
  op sublists  : TransitionList                         -> TransitionListMagma [memo] .
  op $sublists : TransitionList Nat TransitionListMagma -> TransitionListMagma .
  eq sublists(TL) = $sublists(TL,length(TL),mttlm) .
  eq $sublists(TL,0,TLM) = TLM .
  eq $sublists(T ; TL,s(N),TLM)
   = $sublists(TL ; T,N,(TL,TLM)) .

  op update : SimpleTransition -> Ctx .
  eq update((C, (empty).Ctx))
   = C .
  eq update((C < E | M > , C' < E | M' > ))
   = update((C < E | M' > , C')) .
endfm

fmod REDUCT-UTIL is
  pr META-LEVEL .
  pr CONVERSION .
  pr CTX .
  pr 2TUPLE{String,Rat}
     * (sort Tuple{String,Rat} to RuleName) .

  var  AtS    : AttrSet .
  vars Cn Cn' : Condition .
  var  C      : Ctx .
  var  Eq     : Equation .
  var  M      : Module .
  vars N      : Nat .
  var  Q      : Qid .
  var  Rl     : Rule .
  vars RS RS' : RuleSet .
  var  S      : Sort .
  vars T T'   : Term .

  op get-module : Qid -> [Module] [memo] .
  eq get-module(Q) = upModule(Q,false) .

  op errorRuleName : -> [RuleName] .

  --- Given a quoted identifier of the form '<String>-<Rat>
  --- it returns a pair the rule name ("<String>","<Rat>")
  op rule-name : Qid -> [RuleName] .
  eq rule-name(Q)
   = if find(string(Q),"-",0) =/= notFound
     then (substr(string(Q),0,find(string(Q),"-",0)),
          rat(substr(string(Q),s(find(string(Q),"-",0)),sd(length(string(Q)),1)),10))
     else errorRuleName
     fi .

  --- Given the metarepresentation of a rewrite theory and a context <Ctx>
  --- it adds the equations #STATE# = <Ctx> to the rewrite theory
  op set-state : Module Ctx -> Module .
  eq set-state(M,C)
   = add-equation(M, (eq '#STATE#.Ctx = upTerm(C) [none].)) .

  --- Adds the given equation to the given system module
  op add-equation : Module Equation -> Module .
  eq add-equation(mod H:Header is IL:ImportList sorts SS:SortSet .
      SDS:SubsortDeclSet ODS:OpDeclSet MAS:MembAxSet ES:EquationSet RS:RuleSet endm,
      Eq)
   = mod H:Header is IL:ImportList sorts SS:SortSet .
      SDS:SubsortDeclSet ODS:OpDeclSet MAS:MembAxSet (ES:EquationSet Eq) RS:RuleSet endm .

  op set-rules : Module RuleSet -> Module .
  eq set-rules(mod H:Header is IL:ImportList sorts SS:SortSet .
      SDS:SubsortDeclSet ODS:OpDeclSet MAS:MembAxSet ES:EquationSet RS endm, RS')
   = mod H:Header is IL:ImportList sorts SS:SortSet .
      SDS:SubsortDeclSet ODS:OpDeclSet MAS:MembAxSet ES:EquationSet RS' endm .

---(
  op update-rules : Module RuleSet -> RuleSet .
  op $update-rules : Module RuleSet RuleSet -> RuleSet .
  eq update-rules(M,RS)
   = $update-rules(M,RS,none) .
  eq $update-rules(M,none,RS') = RS' .
  eq $update-rules(M,(rl T => T' [AtS].) RS,RS')
   = $update-rules(M, RS,
      (rl T => update-term(M,T') [AtS].) RS') .
  eq $update-rules(M,(crl T => T' if Cn [AtS].) RS, RS')
   = $update-rules(M, RS,
      (crl T => update-term(M,T') if update-cond(M,Cn) [AtS].) RS') .

  op update-term : Module Term -> Term .
  op update-cond : Module Condition -> Condition .
  op $update-cond : Module Condition Condition -> Condition .
  eq update-term(M,T) = getTerm(metaReduce(M,T)) .
  eq update-cond(M,Cn) = $update-cond(M,Cn,nil) .
  eq $update-cond(M,nil,Cn') = Cn' .
  eq $update-cond(M, T = T' /\ Cn, Cn')
   = $update-cond(M,Cn, Cn' /\ update-term(M,T) = update-term(M,T')) .
  eq $update-cond(M, T := T' /\ Cn, Cn')
   = $update-cond(M,Cn, Cn' /\ update-term(M,T) := update-term(M,T')) .
  eq $update-cond(M, T => T' /\ Cn, Cn')
   = $update-cond(M,Cn, Cn' /\ update-term(M,T) => update-term(M,T')) .
  eq $update-cond(M, T : S /\ Cn, Cn')
   = $update-cond(M,Cn, Cn' /\ update-term(M,T) : S) .
---)

  --- Returns the left-hand side of a rule
  op lhs : Rule -> Term .
  eq lhs(rl T => T' [AtS].) = T .
  eq lhs(crl T => T' if Cn [AtS].) = T .
  --- Returns the right-hand side of a rule
  op rhs : Rule -> Term .
  eq rhs(rl T => T' [AtS].) = T' .
  eq rhs(crl T => T' if Cn [AtS].) = T' .
  --- Returns the condition of a rule
  op cond : Rule -> Condition .
  eq cond(rl T => T' [AtS].) = nil .
  eq cond(crl T => T' if Cn [AtS].) = Cn .

  --- get-sub(M,Rl,T,N) computes the N-th matching substitution
  --- of the left hand side of Rl, under its condition,
  --- to term T; if such substitution does not exists,
  --- then the noMatch value is returned
  op get-sub : Module Rule Term Nat -> MatchPair? .
  eq get-sub(M,Rl,T,N)
   = metaXmatch(M,lhs(Rl),T,cond(Rl),0,1,N) .

  --- Down function for contexts
  op errorCtx : -> [Ctx] .
  op downCtx  : Module Term -> Ctx .
  eq downCtx(M,T) = downTerm(getTerm(metaReduce(M,T)),errorCtx) .
endfm


--- The main objective of this module is to compute
--- all redices of context agains a synchronous
--- rewrite theory
fmod REDUCT is
  pr REDUCT-UTIL .
  pr TERM-UTIL .
  pr TRANSITION .

  vars AtS AtS' : AttrSet .
  vars C C'     : Condition .
  vars Cx Cx'   : Ctx .
  vars CxM CxM' : TransitionList .
  vars M M'     : Module .
  vars N N'     : Nat .
  var  Q        : Qid .
  vars Rl Rl'   : Rule .
  vars RS RS'   : RuleSet .
  vars S S'     : String .
  var  MP       : MatchPair .
  vars T Tl Tr  : Term .
  vars Tl' Tr'  : Term .

  --- get-trans(M,M',Cx) computes the transitions in M' 
  --- from Cx, where M' corresponds to the closure of M.
  --- It returns a magma of extended contexts in which
  --- each transition is annotated with the rule name,
  --- its priority, a subterm of Cx and its delta given
  --- by the instantiation of the right hand side of the rule
  op get-trans : Module Module Ctx -> TransitionList .
  op $get-trans : RuleSet Module RuleSet Ctx Term TransitionList -> TransitionList .
  eq get-trans(M,M',Cx)
   = $get-trans(getRls(M),M',getRls(M'),Cx,upTerm(Cx),niltl) .

  eq $get-trans(none,M',none,Cx,T,CxM) = CxM .
  eq $get-trans(
       (rl Tl  => Tr   [label(Q) AtS].)  RS,
       M',
       (rl Tl' => Tr'  [label(Q) AtS'].) RS',
       Cx, T, CxM)
   = if rule-name(Q) :: RuleName
     then 
       $get-trans(RS,M',RS',Cx,T,
         comp-ctx(rule-name(Q),M',(rl Tl' => Tr' [label(Q) AtS'].), T,Tl',Tr',CxM,0))
     else $get-trans(RS,M',RS',Cx,T,CxM)
     fi .
  eq $get-trans(
       (crl Tl  => Tr  if C  [label(Q) AtS].)  RS,
       M',
       (crl Tl' => Tr' if C' [label(Q) AtS'].) RS',
       Cx, T, CxM)
   = if rule-name(Q) :: RuleName
     then 
       $get-trans(RS,M',RS',Cx,T,
         comp-ctx(rule-name(Q),M',(crl Tl' => Tr' if C' [label(Q) AtS'].), T,Tl',Tr',CxM,0))
     else $get-trans(RS,M',RS',Cx,T,CxM)
     fi .

  --- Computes all possible transitions of a given context
  --- with respect to a rewrite rule
  op comp-ctx : RuleName Module Rule Term Term Term TransitionList Nat -> TransitionList .
  op comp-ctx : RuleName Module Rule Term Term Term TransitionList Nat MatchPair? -> TransitionList .
  eq comp-ctx((S,N),M',Rl,T,Tl,Tr,CxM,N')
   = comp-ctx((S,N),M',Rl,T,Tl,Tr,CxM,N',get-sub(M',Rl,T,N')) .
  eq comp-ctx((S,N),M',Rl,T,Tl,Tr,CxM,N',noMatch)
   = CxM .
  eq comp-ctx((S,N),M',Rl,T,Tl,Tr,CxM,N',MP)
   = comp-ctx((S,N),M',Rl,T,Tl,Tr,
       (CxM ; (S,N,
                downCtx(M',appl-subs(Tl,getSubstitution(MP))),
                downCtx(M',appl-subs(Tr,getSubstitution(MP))))
              ),
     s(N')) .
endfm

--- This module offers the simple but yet important functionality for
--- applying the maximal redexes strategy
fmod MAX-RED-STRATEGY is
  pr TRANSITION .

  var  A         : Aid .
  vars Cx Cx'    : Ctx .
  vars Cx1 Cx2   : Ctx .
  var  Ei        : Eid .
  var  E         : Elem .
  vars Ex Ex'    : Expr .
  vars M M'      : Map .
  vars N N'      : Nat .
  var  STM STM'  : SimpleTransitionMagma .
  var  S         : String .
  vars TL TL'    : TransitionList .
  var  TL''      : TransitionList .
  var  TLM       : TransitionListMagma .

  op apply-strategy : TransitionList -> TransitionList .
 ceq apply-strategy((TL ; (S,N,Cx E,Cx') ; TL' ; (S,N',Cx1 E,Cx2) ; TL''))
   = apply-strategy((TL ; (S,N,Cx E,Cx') ; TL' ; TL''))
  if N < N' = true .
 ceq apply-strategy((TL ; (S,N,Cx E,Cx') ; TL' ; (S,N',Cx1 E,Cx2) ; TL''))
   = apply-strategy((TL ; TL' ; (S,N',Cx1 E,Cx2) ; TL''))
  if N > N' = true .
  eq apply-strategy(TL) 
   = TL [owise] .

  --- returns the maximal set of redices represented as a magma
  --- of maximal simple transitions
  op disjointify  : TransitionList -> SimpleTransitionMagma .
  op $disjointify : TransitionListMagma SimpleTransitionMagma -> SimpleTransitionMagma .
  eq disjointify(TL)
   = if disjoint?(TL)
     then to-simple-trans(TL)
     else $disjointify(sublists(TL),mtstm)
     fi .
  eq $disjointify((TL,TLM),STM)
   = $disjointify(TLM,(disjointify(TL),STM)) .
  eq $disjointify(mttlm,STM) = subsume(STM) .

  op apply-transitions : SimpleTransitionMagma -> SimpleTransitionMagma .
  op $apply-transitions : SimpleTransitionMagma SimpleTransitionMagma -> SimpleTransitionMagma .
  eq apply-transitions(STM)
   = $apply-transitions(STM,mtstm) .
  eq $apply-transitions(mtstm,STM') = STM' .
  eq $apply-transitions(((Cx,Cx'),STM),STM')
   = $apply-transitions(STM,(STM',(Cx,update-context((Cx,Cx'))))) .
  op update-context : SimpleTransition -> Ctx .
  eq update-context((Cx, (empty).Ctx)) = Cx .
  eq update-context((Cx, < Ei | (empty).Map > Cx'))
   = update-context((Cx, Cx')) .
  eq update-context((Cx < Ei | A : Ex, M > , Cx' < Ei | A : Ex', M' > ))
   = update-context((Cx < Ei | A : Ex', M > , Cx' < Ei | M' > )) . 
endfm

fmod SYNCHRONOUS is
  pr MAX-RED-STRATEGY .
  pr REDUCT .
  pr THEORY-CLOSURE .

  var C    : Ctx .
  var Q    : Qid .  

  op sync-redixes : Ctx Qid -> SimpleTransitionMagma .
  eq sync-redixes(C,Q)
   = apply-transitions(disjointify(apply-strategy(get-trans(get-module(Q),
       set-state(close-theory(get-module(Q)),C),C)))) .

  op get-trans-ext : Ctx Qid -> TransitionList .
  eq get-trans-ext(C,Q) = get-trans(get-module(Q),set-state(close-theory(get-module(Q)),C),C) .
endfm
