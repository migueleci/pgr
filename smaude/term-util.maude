***(

    This file is part of SMaude, a framework for supporting
    synchronous set rewriting in Maude.

    Copyright (C) 2008-2013 Camilo Rocha, camilo.rocha@gmail.com

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
)

****                                                             Term utilities
****                                                       Author: Camilo Rocha
****                                        To be used with Maude 2.6 or higher
****                                                 Taken from Full Maude 2.6b

fmod TERM-UTIL is
  protecting META-TERM .
  protecting META-LEVEL .
  protecting CONVERSION .

  vars N N' : Nat .  var Q : Qid .
  var S S' Subst Subst' SUB : Substitution .
  var V : Variable .  var C : Constant .
  var T : Term .  var TL : TermList .  var NTL : NeTermList .


  --- apply substitution ---
  op _<<_ : Term Substitution -> Term .
  eq TL << none = TL .
  eq C << Subst = C .
  eq V << ((V <- T) ; Subst) = T .
  eq V << Subst = V [owise] .
  eq Q[TL] << Subst = Q[TL << Subst] .

  op _<<_ : TermList Substitution -> TermList .
  eq (T, NTL) << Subst = (T << Subst, NTL << Subst) .
  eq empty << Subst = empty .

  op _<<_ : Substitution Substitution -> Substitution .
  eq S << (none).Substitution = S .
  eq (none).Substitution << S = (none).Substitution .
  eq ((V <- T) ; S') <<  S
   = (V <- (T << S)) ;(S' << S) .

  --- Rename each # variables in substitutions
  --- User input should not have variables starting with "#".
  op norm : Substitution -> Substitution .
  op norm : TermList -> TermList .
  eq norm((V <- T) ; Subst)    = V <- norm(T) ; norm(Subst) .
  eq norm((none).Substitution) = (none).Substitution .
  eq norm((T, NTL)) = norm(T), norm(NTL) .
  eq norm(Q[TL]) = Q[norm(TL)] .
  eq norm(empty) = empty .
  eq norm(C) = C .
  eq norm(V) = if substr(string(V), 0, 1) == "#" 
               then qid("V" + string(V)) else V fi .

  op errorTerm : -> [Term] .

  --- Application of substitutions for terms with sort Ctx
  op appl-subs : Term Substitution? -> [Term] .
  eq appl-subs(T:Term, noMatch)
   = errorTerm .
  eq appl-subs(T:Term,S:Substitution)
   = T:Term << S:Substitution .
endfm

eof

--- Taken from Full Maude 2.6b
fmod TERM-HANDLING is
  protecting META-TERM .
  protecting META-LEVEL .
  protecting EXT-BOOL . *** For and-then

  var T T' T'' : Term .
  var C C' : Constant .
  var QIL : QidList .
  var N N' : Nat .
  var NL NL' : NatList .
  var Q F F' : Qid .
  var AtS : AttrSet .
  var EqS : EquationSet .
  var Eq : Equation .
  var Cond : Condition .
  var TP : Type .
  var TPL TPL' : TypeList .
  var TL TL' TL'' : TermList .
  var B : Bool .
  var V V' : Variable .
  var Ct : Context .
  var CtL : NeCTermList .
  var NeTL : NeTermList .
  var M : Module .

  *** root  ******************************
  op root : Term -> Qid .
  eq root(V) = V .
  eq root(C) = C .
  eq root(F[TL]) = F .

  *** size  ******************************
  op size : TermList -> Nat .
  eq size(empty) = 0 .
  eq size((T,TL)) = s(size(TL)) .

  *** elem_of_ *****************************************************
  op elem_of_ : Nat TermList ~> Term .
  eq elem 1 of (T,TL) = T .
  eq elem s(s(N)) of (T,TL) = elem s(N) of TL .

  *** subTerm_of_ *****************************************************
  op subTerm_of_ : NatList Term ~> Term .
  eq subTerm NL of T = subTerm* NL of T  .

  op subTerm*_of_ : NatList Term ~> Term .
  eq subTerm* nil of T = T .
  eq subTerm* N NL of (F[TL]) = subTerm* NL of (elem N of TL) .

  *** ToDo: UPGRADE THIS NOTION TO MODULO AC *********************
  *** is_subTermOf_ *****************************************************
  op is_subTermOf_ : Term TermList -> Bool .
  eq is T subTermOf T = true .
  eq is T subTermOf (F[TL]) = is T subTermOf TL .
  eq is T subTermOf (T',NeTL) = is T subTermOf T' 
                                or-else is T subTermOf NeTL .
  eq is T subTermOf T' = false [owise] .

  *** noVarOfSort_In_ *****************************************************
  op noVarOfSort_In_ : Type TermList -> Bool .
  eq noVarOfSort T:Type In V = getType(V) =/= T:Type .
  eq noVarOfSort T:Type In (F[TL]) = noVarOfSort T:Type In TL .
  eq noVarOfSort T:Type In (T',NeTL)
   = noVarOfSort T:Type In T' and noVarOfSort T:Type In NeTL .
  eq noVarOfSort T:Type In X:TermList = true [owise] .

  *** findSubTermOf_In_ ***********************************************
  op findSubTermOf_In_ : NeCTermList TermList ~> Term .
  eq findSubTermOf (TL, [], TL') In (TL, T, TL') = T .
  eq findSubTermOf (TL, F[CtL], TL'') In (TL, F[TL'], TL'')
   = findSubTermOf CtL In TL' .

  *** replaceElem_of_by_ ****************************************************
  op replaceElem_of_by_ : Nat TermList Term ~> TermList .
  eq replaceElem 1 of (T,TL) by T' = (T',TL) .
  eq replaceElem s(s(N)) of (T,TL) by T' = (T,replaceElem s(N) of TL by T') .

  *** replaceSubTerm_of_by_ *************************************************
  op replaceSubTerm_of_by_ : NatList TermList Term ~> TermList .
  eq replaceSubTerm nil of T by T' = T' .
  eq replaceSubTerm N NL of (F[TL]) by T'
   = F[replaceSubTermL N NL of TL by T'] .

  op replaceSubTermL_of_by_ : NatList TermList Term ~> TermList .
  eq replaceSubTermL 1 NL of (T,TL) by T'
   = (replaceSubTerm NL of T by T', TL) .
  eq replaceSubTermL s(s(N)) NL of (T,TL) by T'
   = (T,replaceSubTermL s(N) NL of TL by T') .

  op replaceTerm_by_in_ : Term Term TermList ~> TermList .
  eq replaceTerm T by T' in T = T' .
  eq replaceTerm T by T' in (F[TL]) = F[replaceTerm T by T' in TL] .
  eq replaceTerm T by T' in T'' = T'' [owise] .
  eq replaceTerm T by T' in (T'',NeTL) 
   = (replaceTerm T by T' in T'',replaceTerm T by T' in NeTL) .

  *** context replacement **************************************************

  op _[_] : Context Context -> Context .
  op _[_] : NeCTermList Context -> NeCTermList .
  eq [] [ Ct ] = Ct .
  eq (F[CtL])[ Ct ] = F[ CtL [ Ct ] ] .
  eq (CtL,NeTL) [Ct] = (CtL [Ct] ), NeTL .
  eq (NeTL,CtL) [Ct] = NeTL, (CtL [Ct] ) .

  op _[_] : Context Term -> Term .
  op _[_] : NeCTermList Term -> TermList .
  eq [] [ T ] = T .
  eq (F[CtL])[ T ] = F[ CtL [ T ] ] .
  eq (CtL,NeTL) [T] = (CtL [T] ), NeTL .
  eq (NeTL,CtL) [T] = NeTL, (CtL [T] ) .

  *** is_substring_ *****************************************
  op is_substring_ : Qid Qid -> Bool [memo] .
  eq is F:Qid substring F':Qid
   = rfind(string(F':Qid), string(F:Qid), length(string(F':Qid))) =/= notFound .

  *** addprefix_To_ addsufix_To_ *****************************************
  op addprefix_To_ : Qid Variable -> Variable [memo] .
  eq addprefix Q To V
   = qid(string(Q) + string(getName(V)) + ":" + string(getType(V))) .
   
  op addprefix_To_ : Qid Constant -> Constant [ditto] .
  eq addprefix Q To F
   = if noUnderBar(F) and getName(F) :: Qid then
       if getType(F) :: Type then
         qid(string(Q) + string(getName(F)) + "." + string(getType(F)))
       else
         qid(string(Q) + string(getName(F)))
       fi
     else
       qid(string(Q) + string(F))
     fi .

  op addsufix_To_ : Qid Variable -> Variable [memo] .
  eq addsufix Q To V
   = qid(string(getName(V)) + string(Q) + ":" + string(getType(V))) .
   
  op addsufix_To_ : Qid Constant -> Constant [ditto] .
  eq addsufix Q To F
   = if noUnderBar(F) and getName(F) :: Qid then
       if getType(F) :: Type then
         qid(string(getName(F)) + string(Q) + "." + string(getType(F)))
       else
         qid(string(getName(F)) + string(Q))
       fi
     else
       qid(string(F) + string(Q))
     fi .

  op addType_ToVar_ : Type Qid -> Variable [memo] .
  eq addType TP:Qid ToVar V:Qid
   = qid(string(V:Qid) + ":" + string(TP:Qid)) .

  *** noUnderBar (auxiliary) ****************************
  op noUnderBar : Qid -> Bool .
  eq noUnderBar(F)
   = rfind(string(F), "_", length(string(F))) == notFound .

  *** addType  ******************************
  op addType : Qid Type -> Qid .
  eq addType(F,TP)
   = if noUnderBar(F) and getName(F) :: Qid then
       qid( string(getName(F)) + "." + string(TP) )
     else
       qid( string(F) + "." + string(TP) )
     fi .

  *** addTypeVar  ******************************
  op addTypeVar : Qid Type -> Qid .
  eq addTypeVar(F,TP)
   = qid( string(F) + ":" + string(TP) ) .

  *** createTerm  ******************************
  op createTerm : Qid TypeList -> Term .


endfm

--- Taken from Full Maude 2.6b
fmod SUBSTITUTION-HANDLING is
  protecting META-TERM .
  protecting META-LEVEL .
  protecting TERM-HANDLING .

  var S S' Subst Subst' : Substitution .
  var V V' : Variable .
  var C C' : Constant .
  var Ct : Context .
  var T T' T1 T2 T1' T2' T1'' T2'' : Term .
  var F F' : Qid .
  var TL TL' TL1 TL2 TL1' TL2' : TermList .
  var Att : AttrSet .
  var RLS : RuleSet .
  var Rl : Rule .
  var TP : Type .
  var N : Nat .
  var NeTL : NeTermList .
  var CtL : NeCTermList .

  --- Apply Substitution to Term --------------------------------------------
  op _<<_ : Term Substitution -> Term .
  eq TL << none = TL .
  eq C << Subst = C .
  eq V << ((V <- T) ; Subst) = T .
  eq V << Subst = V [owise] .
  eq F[TL] << Subst = F[TL << Subst] .

  op _<<_ : TermList Substitution -> TermList .
  eq (T, NeTL) << Subst = (T << Subst, NeTL << Subst) .
  eq empty << Subst = empty .

  op _<<_ : Context Substitution -> Context .
  eq Ct << none = Ct .
  eq [] << Subst = [] .
  eq F[CtL,NeTL] << Subst = F[CtL << Subst,NeTL << Subst] .
  eq F[NeTL,CtL] << Subst = F[NeTL << Subst, CtL << Subst] .
  eq F[Ct] << Subst = F[Ct << Subst] .

  op _<<_ : Substitution Substitution -> Substitution .
  eq S << (none).Substitution = S .
  eq (none).Substitution << S = (none).Substitution .
  eq ((V' <- T) ; S') <<  S
   = (V' <- (T << S))
     ;
     (S' << S) .

  --- Combine Substitutions -------------------------------------------------
  op _.._ : Substitution Substitution -> Substitution .
  eq S .. S' = (S << S') ; S' .

  --- Restrict Assignments to Variables in a Term ----------------------
  op _|>_ : Substitution TermList -> Substitution .

  eq Subst |> TL = Subst |>* Vars(TL) .

  op _|>*_ : Substitution TermList -> Substitution .
---   eq noMatch |>* TL = noMatch .
  eq Subst |>* TL = Subst |>** TL [none] .

  op _|>**_[_] : Substitution TermList 
                 Substitution -> Substitution .
  eq none |>** TL [Subst']
   = Subst' .
  eq ((V <- V) ; Subst) |>** TL [Subst']
   = Subst |>** TL [Subst'] .
  eq ((V <- T') ; Subst) |>** TL [Subst']
    = Subst |>** TL
      [Subst' ; if any V in TL then (V <- T') else none fi] . 

  --- Remove Variables from list ----------------------
  op _intersect_ : TermList TermList -> TermList .
  eq (TL1,T,TL2) intersect (TL1',T,TL2') 
   = (T,((TL1,TL2) intersect (TL1',TL2'))) .
  eq TL intersect TL' = empty [owise] .

  op _intersectVar_ : TermList TermList -> TermList .
  eq TL1 intersectVar TL2 
   = TL1 intersectVar* Vars(TL2) . 

  op _intersectVar*_ : TermList TermList -> TermList .
  eq (T,TL1) intersectVar* TL2 
   = (if any Vars(T) in TL2 then T else empty fi,TL1 intersectVar* TL2) .
  eq empty intersectVar* TL2 
   = empty .

  --- Variables ---
  op Vars : GTermList -> TermList .
  eq Vars((T,TL:GTermList)) = VarsTerm(T),Vars(TL:GTermList) .
  eq Vars((Ct,TL:GTermList)) = VarsTerm(Ct),Vars(TL:GTermList) .
  eq Vars(empty) = empty .
  
  op VarsTerm : Term -> TermList . ---warning memo
  eq VarsTerm(V) = V .
  eq VarsTerm(F[TL:TermList]) = Vars(TL:TermList) .
  eq VarsTerm(C) = empty .
  
  op VarsTerm : Context -> TermList . ---warning memo
  eq VarsTerm(F[TL:GTermList]) = Vars(TL:GTermList) .
  
  --- membership ---
  op _in_ : Term TermList -> Bool .
  eq T in (TL,T,TL') = true .
  eq T in TL = false [owise] .
  
  --- membership ---
  op any_in_ : TermList TermList -> Bool . --- [memo] .
  eq any empty in TL = false .
  eq any (TL1,T,TL2) in (TL1',T,TL2') = true .
  eq any TL in TL' = false [owise] .
  
  --- membership ---
  op all_in_ : TermList TermList -> Bool . --- [memo] .
  eq all empty in TL = true .
  eq all (TL1,T,TL2) in (TL1',T,TL2') = all (TL1,TL2) in (TL1',T,TL2') .
  eq all TL in TL' = false [owise] .
  
  --- Occur check ---
  op allVars_inVars_ : GTermList GTermList -> Bool .
  eq allVars TL:GTermList inVars TL':GTermList 
   = all Vars(TL:GTermList) in Vars(TL':GTermList) .

  op anyVars_inVars_ : GTermList GTermList -> Bool .
  eq anyVars TL:GTermList inVars TL':GTermList 
   = any Vars(TL:GTermList) in Vars(TL':GTermList) .

---   op dom : Substitution -> TermList .
---   eq dom(V <- T ; Subst) = (V,dom(Subst)) .
---   eq dom(none) = empty .
  
---   op range : Substitution -> TermList .
---   eq range(V <- T ; Subst) = (T,range(Subst)) .
---   eq range(none) = empty .

  op rangeVars : Substitution -> TermList .
  eq rangeVars(V <- T ; Subst) = (Vars(T),rangeVars(Subst)) .
  eq rangeVars(none) = empty .

  op dom_inVars_ : Substitution TermList -> Bool .
  eq dom Subst inVars TL = dom Subst in Vars(TL) .

  op dom_in_ : Substitution TermList -> Bool .
  eq dom (V <- T ; Subst) in (TL1,V,TL2) = true .
  eq dom Subst in TL = false [owise] .

  op range_inVars_ : Substitution TermList -> Bool .
  eq range Subst inVars TL = range Subst in Vars(TL) .

  op range_in_ : Substitution TermList -> Bool .
  eq range (V <- T ; Subst) in TL
   = any Vars(T) in TL or-else range Subst in TL .
  eq range none in TL
   = false .

  op valid-occur-check? : Substitution -> Bool .
  eq valid-occur-check?(Subst)
   = not (dom Subst inVars (rangeVars(Subst))) .

--- The following functions were added by Camilo Rocha
--- for the Syncrhonous Maude project
  op errorTerm : -> [Term] .

  --- Application of substitutions for terms with sort Ctx
  op appl-subs : Term Substitution? -> [Term] .
  eq appl-subs(T:Term, noMatch)
   = errorTerm .
  eq appl-subs(T:Term,S:Substitution)
   = T:Term << S:Substitution .
endfm

