% !TEX root = main.tex

\chapter{Lenguaje de programaci\'on}
\label{chapter.lang}

Este cap\'itulo presenta una propuesta de un lenguaje de programaci\'on basado en el modelo \SCCP definido en el Cap\'itulo~\ref{chapter.sccp}. La principal raz\'on para crear este lenguaje es permitir a los programadores tener una medio m\'as sencillo para modelar sistemas distribuidos de informaci\'on.  

La Secci\'on~\ref{ebnf.lang} presenta la sintaxis del lenguaje de programaci\'on en la notaci\'on EBNF. La Secci\'on~\ref{sccp.lang} muestra c\'omo el lenguaje esta relacionado con el modelo \SCCP descrito en el Cap\'itulo~\ref{chapter.sccp}. La Secci\'on~\ref{new.lang} presenta una explicaci\'on de los nuevos elementos del lenguaje. Por \'ultimo, la Secci\'on~\ref{example.lang} contiene algunos ejemplos del funcionamiento del lenguaje de programaci\'on.

%% Secci\'on:  %%
\section{EBNF del lenguaje}
\label{ebnf.lang}

EBNF (del ing\'es, Extended Backus-Naur Form) es un metalenguaje utilizado para definir formalmente la sintaxis de gram\'aticas libres de contexto, que utiliza expresiones regulares para permitir escribir especificaciones compactas. 

Una descripci\'on EBNF es una lista no ordenada de reglas EBNF. Cada una de las reglas EBNF esta compuesta de tres partes: el lado izquierdo, el lado derecho y el s\'imbolo `$::=$' separando los dos lados, este s\'imbolo debe ser leido como ``se define como''~\cite{ebnfdoc}. El lado izquierdo contiene una palabra escrita en min\'uscula y cursiva delimitada por los caracteres `$\langle$' y `$\rangle$', la cual indica el nombre de la regla EBNF. En el lado derecho se encuentra la definici\'on asociada al este nombre. 

Los nombres asignados en el lado izquierdo de las reglas EBNF pueden ser utilizados como parte de la definici\'on asociada en el lado derecho de las reglas, inclusive dentro de la misma regla, es decir, que puede haber recursi\'on en la descripci\'on del lenguaje.

Las reglas EBNF pueden incluir diez caracteres con significado especial: `$::=$', `$|$', `$+$', `$*$', `$[$', `$]$', `$($', `$)$', `$?$' y `$;$'. Todos los dem\'as caracteres diferentes de los listados anteriormente y de los nombres de las reglas EBNF se definen por si mismos (v.gr. letras, d\'igitos, signos de puntuaci\'on). A continuaci\'on se presenta una explicaci\'on de algunos de los caracteres especiales:

\begin{itemize}
\item Cada regla EBNF debe finalizar con el car\'acter `$;$'. 
\item `$*$' es un operador unario posfijo, el cual indica que la expresi\'on aparece cero o m\'as veces. 
\item `$+$' es un operador unario posfijo, el cual indica que la expresi\'on aparece una o m\'as veces.
\item `$?$' es un operador unario posfijo, el cual indica que la expresi\'on aparece cero o una vez.
\item Multiples opciones en la definici\'on de un regla EBNF deben estar separadas por el car\'acter `$|$'.
\item Todas las expresiones delimitadas por comillas simples aparecen de la misma forma en el lenguaje de programaci\'on.
\end{itemize}

\begin{figure}

\begin{flalign*}
\nterm{system} & ::= \nterm{variables}? \nterm{body} \ ; \\
\nterm{variables} & ::= \textterm{var} \nterm{id}+ \ (\textterm{Int} | \textterm{Bool}) \ ; \\
\nterm{body} & ::= \textterm{begin} \nterm{processline}+ \ \textterm{end} \ ; \\
\nterm{processline} & ::= \nterm{process} \textterm{.}  \ ; \\
\nterm{process} & ::= \textterm{tell(} \ \nterm{constraint}  \textterm{)} \ ; \\
	& \bor \textterm{ask} \ (\textterm{<} \ \nterm{location} \textterm{>})? \ \nterm{constraint} \textterm{->}  \nterm{process} \ ; \\
	& \bor \nterm{process} \textterm{||}  \nterm{process} \ ; \\
	& \bor  \textterm{[}  \nterm{process}  \textterm{]\_} \ \nterm{integer} \ ; \\
\nterm{constraint} & ::= \nterm{boolean} \ ; \\
	& \bor \nterm{id} \ ; \\
	& \bor \nterm{expression} \ ; \\
	& \bor \nterm{constraint} \ \textterm{and} \ \nterm{constraint} \ ; \\
\nterm{location} & ::= \nterm{integer} (\textterm{.} \nterm{integer})* \ ; \\
\nterm{expression} & ::= \nterm{id} \nterm{operator} ( \nterm{id} \ | \ \nterm{integer} ) \ ; \\
\nterm{operator} & ::= \textterm{>} \ | \ \textterm{<} \ | \ \textterm{=} \ | \ \textterm{=/=} \ | \ \textterm{>=} \ | \ \textterm{<=} \ ; \\
\nterm{boolean} & ::= \textterm{true} \ | \ \textterm{false} \ ; \\
\nterm{integer} & ::= \textnormal{[0-9]}+ \ ; \\
\nterm{id} & ::= \textnormal{[A-Z] [A-Z0-9]}* \ ;  
\end{flalign*}

\caption{EBNF del lenguaje de programaci\'on.}
\label{fig:ebnf}
\end{figure}

En la Figura~\ref{fig:ebnf} se presenta la descripci\'on EBNF del lenguaje de programaci\'on propuesto. La explicaci\'on de cada una de las reglas EBNF se presenta en las secciones~\ref{sccp.lang} y ~\ref{new.lang}.

%% Secci\'on:  %%
\section{Relaci\'on con \SCCP}
\label{sccp.lang}

El lenguaje de programaci\'on que se propone est\'a basado en el modelo \SCCP presentado en el Cap\'itulo~\ref{chapter.sccp}, y es ejecutado en el ambiente de Maude por medio de la especificaci\'on formal presentada en el Cap\'itulo~\ref{chapter.rew}. Por esta raz\'on el lenguaje debe proveer la sintaxis parar los procesos que se han definido hasta el momento. Esta secci\'on contiene una explicaci\'on de la relaci\'on entre la definici\'on de \SCCP y las reglas EBNF de la Figura~\ref{fig:ebnf}.

En primer lugar el 

\begin{itemize}
\item \cde{system} esta definido
\end{itemize}


%% Secci\'on:  %%
\section{Nuevas caracter\'isticas}
\label{new.lang}

explain the new constructs of the language

\begin{itemize}
\item \cde{system} esta definido
\end{itemize}


%% Secci\'on:  %%
\section{Ejemplo}
\label{example.lang}

encode the example from the previous section in the language
encode another example in the language
